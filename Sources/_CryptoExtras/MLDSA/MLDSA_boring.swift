//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftCrypto open source project
//
// Copyright (c) 2024 Apple Inc. and the SwiftCrypto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.md for the list of SwiftCrypto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Crypto
import Foundation

@_implementationOnly import CCryptoBoringSSL
@_implementationOnly import CCryptoBoringSSLShims

/// Types associated with the ML-DSA algorithm
@_documentation(visibility: public)
public enum MLDSA {}

extension MLDSA {
    public struct PrivateKey: Sendable {
        fileprivate let pointer: UnsafeMutablePointer<MLDSA65_private_key>
        private let seedPointer: UnsafeMutablePointer<UInt8>

        public init() {
            self.pointer = UnsafeMutablePointer<MLDSA65_private_key>.allocate(capacity: 1)
            self.seedPointer = UnsafeMutablePointer<UInt8>.allocate(capacity: MLDSA.seedSizeInBytes)
            CCryptoBoringSSL_MLDSA65_generate_key(
                UnsafeMutablePointer<UInt8>.allocate(capacity: MLDSA.PublicKey.bytesCount),
                self.seedPointer,
                self.pointer
            )
        }

        /// Initialize a ML-DSA private key from a seed.
        /// 
        /// The seed must be at least 32 bytes long.
        /// Any additional bytes in the seed are ignored.
        /// 
        /// > Warning: The BoringSSL docs state that the seed should be one generated by the library when generating a new private key.
        /// 
        /// - Parameter seed: The seed to use to generate the private key.
        /// 
        /// - Throws: `CryptoKitError.incorrectKeySize` if the seed is not at least 32 bytes long.
        public init(from seed: some DataProtocol) throws {
            guard seed.count >= MLDSA.seedSizeInBytes else {
                throw CryptoKitError.incorrectKeySize
            }

            let seedPtr = UnsafeMutablePointer<UInt8>.allocate(capacity: MLDSA.seedSizeInBytes)
            seedPtr.initialize(from: seed.regions.flatMap { $0 }, count: MLDSA.seedSizeInBytes)

            self.pointer = UnsafeMutablePointer<MLDSA65_private_key>.allocate(capacity: 1)
            guard CCryptoBoringSSL_MLDSA65_private_key_from_seed(
                self.pointer,
                seedPtr,
                MLDSA.seedSizeInBytes
            ) == 1 else {
                throw CryptoKitError.incorrectKeySize
            }

            self.seedPointer = UnsafeMutablePointer<UInt8>.allocate(capacity: MLDSA.seedSizeInBytes)
            self.seedPointer.initialize(from: seedPtr, count: MLDSA.seedSizeInBytes)
        }

        public var seed: Data {
            return Data(bytes: self.seedPointer, count: MLDSA.seedSizeInBytes)
        }

        public var publicKey: PublicKey {
            return PublicKey(privateKey: self)
        }

        public func signature<D: DataProtocol>(for data: D) -> Signature {
            let output = Array<UInt8>(unsafeUninitializedCapacity: Signature.bytesCount) { bufferPtr, length in
                data.regions.first!.withUnsafeBytes { dataPtr in
                    CCryptoBoringSSL_MLDSA65_sign(
                        bufferPtr.baseAddress,
                        self.pointer,
                        dataPtr.baseAddress,
                        dataPtr.count,
                        nil,
                        0
                    )
                }
                length = Signature.bytesCount
            }
            return Signature(signatureBytes: output)
        }

        public static let bytesCount = 4032
    }
}

extension MLDSA {
    public struct PublicKey: Sendable {
        private let pointer: UnsafeMutablePointer<MLDSA65_public_key>

        fileprivate init(privateKey: PrivateKey) {
            self.pointer = UnsafeMutablePointer<MLDSA65_public_key>.allocate(capacity: 1)
            CCryptoBoringSSL_MLDSA65_public_from_private(self.pointer, privateKey.pointer)
        }

        /// Initialize a ML-DSA public key from a seed.
        /// 
        /// The seed must be at least 32 bytes long.
        /// Any additional bytes in the seed are ignored.
        /// 
        /// > Warning: The BoringSSL docs state that the seed should be one generated by the library when generating a new private key.
        /// 
        /// - Parameter seed: The seed to use to generate the public key.
        /// 
        /// - Throws: `CryptoKitError.incorrectKeySize` if the seed is not at least 32 bytes long.
        public init(from seed: some DataProtocol) throws {
            self.init(privateKey: try PrivateKey(from: seed))
        }

        public func isValidSignature<D: DataProtocol>(_ signature: Signature, for data: D) -> Bool {
            return signature.withUnsafeBytes { signaturePtr in
                let rc: CInt = data.regions.first!.withUnsafeBytes { dataPtr in
                    return CCryptoBoringSSL_MLDSA65_verify(
                        self.pointer,
                        signaturePtr.baseAddress,
                        signaturePtr.count,
                        dataPtr.baseAddress,
                        dataPtr.count,
                        nil,
                        0
                    )
                }
                return rc == 1
            }
        }

        public static let bytesCount = 1952
    }
}

extension MLDSA {
    public struct Signature: Sendable, ContiguousBytes {
        public var rawRepresentation: Data

        public init<D: DataProtocol>(rawRepresentation: D) {
            self.rawRepresentation = Data(rawRepresentation)
        }

        internal init(signatureBytes: [UInt8]) {
            self.rawRepresentation = Data(signatureBytes)
        }

        public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
            try self.rawRepresentation.withUnsafeBytes(body)
        }

        public static let bytesCount = 3309
    }
}

extension MLDSA {
    public static let seedSizeInBytes = 32
}
